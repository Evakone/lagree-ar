<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LCS+E AR Experience</title>

  <!-- Brand font - Zen Kaku Gothic New -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New:wght@400;500;700&display=swap" rel="stylesheet">

  <!-- Model Viewer -->
  <script type="module" src="https://unpkg.com/@google/model-viewer@^3.0.0/dist/model-viewer.min.js"></script>

  <style>
    :root {
      --color-black: #000;
      --color-white: #fff;
      --spacing-sm: .5rem;
      --spacing-md: .75rem;
      --spacing-lg: 1rem;
      --radius-md: 10px;
      --z-fixed: 10;
      --font: 'Zen Kaku Gothic New', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    html, body { height: 100%; margin: 0; font-family: var(--font); background: var(--color-black); color: var(--color-white); }

    .app { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

    /* Header */
    .header { position: fixed; top: 0; left: 0; right: 0; z-index: var(--z-fixed); display: flex; align-items: center; justify-content: center; gap: var(--spacing-lg); padding: var(--spacing-md) var(--spacing-lg); background: rgba(0,0,0,.7); backdrop-filter: blur(8px); }
    .header .left, .header .right { position: absolute; top: 50%; transform: translateY(-50%); }
    .header .left { left: var(--spacing-lg); }
    .header .right { right: var(--spacing-lg); }
    .brand-dot { width: 40px; height: 40px; border-radius: 50%; background: #000; display: grid; place-items: center; }
    .brand-dot img { width: 26px; height: 26px; object-fit: contain; filter: invert(1); }
    .title { margin: 0; font-weight: 600; font-size: 1rem; text-align: center; }

    /* Model Viewer fills screen under header */
    model-viewer { width: 100%; height: 100%; display: block; background: var(--color-black); --poster-color: transparent; }

    .btn { background: rgba(255,255,255,.12); color: #fff; border: 1px solid rgba(255,255,255,.25); padding: .45rem .7rem; border-radius: 8px; font-size: .8rem; cursor: pointer; }
    .btn:active { transform: scale(0.97); }

    /* AR button (slotted) visual boost */
    .ar-cta { position: absolute; right: var(--spacing-lg); bottom: calc(3.5rem + var(--spacing-lg) + env(safe-area-inset-bottom, 0)); z-index: var(--z-fixed); }
    .ar-cta .btn { background:#fff; color:#000; border:none; box-shadow: 0 8px 20px rgba(0,0,0,.35); }


    /* Loader */
    .loader { position:absolute; inset:0; display:grid; place-items:center; background: rgba(0,0,0,.8); z-index: var(--z-fixed); }
    .loader-inner { text-align:center; padding: 1rem 1.25rem; border: 1px solid rgba(255,255,255,.2); border-radius: 12px; background: rgba(0,0,0,.6); }
    .loader-inner img { width: 64px; height:64px; display:block; margin: 0 auto .75rem; filter: invert(1); }

    /* Gesture hint */
    .gesture-hint { position: absolute; bottom: 5.5rem; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 1rem; padding: 0.75rem 1.25rem; border-radius: 999px; background: rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(10px); color: #fff; font-size: 0.8rem; letter-spacing: 0.02em; text-transform: uppercase; opacity: 0; pointer-events: none; transition: opacity 0.4s ease; z-index: calc(var(--z-fixed) + 1); }
    .gesture-hint.visible { opacity: 0.9; }
    .gesture-item { display: flex; align-items: center; gap: 0.35rem; white-space: nowrap; }
    .gesture-emoji { font-size: 1.1rem; }

    /* Animation control */
    .animation-control { position: absolute; bottom: 8rem; left: 50%; transform: translateX(-50%); z-index: calc(var(--z-fixed) + 1); }
    .animation-control .btn { background: #fff; color: #000; border: none; box-shadow: 0 8px 20px rgba(0,0,0,.35); font-weight: 600; }
    .animation-control .btn:active { transform: scale(0.95); }

    /* Debug controls */
    .debug-controls { position: absolute; top: 5rem; right: var(--spacing-lg); z-index: calc(var(--z-fixed) + 1); display: flex; flex-direction: column; gap: 0.5rem; }
    .debug-controls .btn { background: rgba(255,0,0,0.8); color: #fff; border: none; font-size: 0.7rem; padding: 0.3rem 0.5rem; }
    .debug-controls .btn:active { transform: scale(0.95); }
  </style>
</head>
<body>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="left">
        <div class="brand-dot"><img src="/assets/lcse-logo-AR-loader.png" alt="LCS+E"></div>
      </div>
      <h1 class="title">Mural AR Experience</h1>
      <div class="right">
        <a href="/mindar.html" class="btn" style="text-decoration: none;">Marker AR</a>
      </div>
    </header>

    <!-- Loader -->
    <div class="loader" id="loader">
      <div class="loader-inner">
        <img src="/assets/lcse-logo-AR-loader.png" alt="Loading" />
        <div id="loadingText">Loading 3D models‚Ä¶</div>
      </div>
    </div>

    <!-- Model Viewer (single source of truth) -->
    <model-viewer
      id="mv"
      src="/assets/models/LCSE-AR-Back-Wall-Clean-Parented-pipeline.glb"
      ios-src="/assets/models/LCSE-AR-Back-Wall-Clean-Parented.usdz"
      alt="LCS+E Street Sign - Interactive 3D Model"
      ar
      ar-modes="webxr scene-viewer quick-look"
      ar-scale="auto"
      camera-controls
      environment-image="neutral"
      poster="/assets/lcse-logo-AR-loader.png"
      exposure="1.0"
      xr-environment
      loading="eager"
      reveal="auto"
      disable-zoom
      interaction-prompt="none">
      <!-- Slotted AR button so browsers allow AR -->
      <div slot="ar-button" class="ar-cta"><button class="btn" id="arBtn">üëÅÔ∏è View in AR</button></div>
    </model-viewer>

    <div class="gesture-hint" id="gestureHint">
      <span class="gesture-item"><span class="gesture-emoji">ü§è</span>Scale</span>
      <span class="gesture-item"><span class="gesture-emoji">‚òùÔ∏è</span>Move</span>
      <span class="gesture-item"><span class="gesture-emoji">üîÑ</span>Rotate</span>
    </div>

    <!-- Animation control for AR mode -->
    <div class="animation-control" id="animationControl" style="display: none;">
      <button class="btn" id="playAnimationBtn">‚ñ∂Ô∏è Play Animation</button>
    </div>

    <!-- Debug controls -->
    <div class="debug-controls" id="debugControls" style="display: none;">
      <button class="btn" id="forceLoadBtn">üîÑ Force Load</button>
      <button class="btn" id="checkReadinessBtn">üîç Check Readiness</button>
    </div>
  </div>

  <script>
    // Enhanced AR Scene Manager
    class MuralARExperience {
      constructor() {
        this.mv = document.getElementById('mv');
        this.loader = document.getElementById('loader');
        this.gestureHint = document.getElementById('gestureHint');
        this.animationControl = document.getElementById('animationControl');
        this.playAnimationBtn = document.getElementById('playAnimationBtn');
        this.debugControls = document.getElementById('debugControls');
        this.forceLoadBtn = document.getElementById('forceLoadBtn');
        this.checkReadinessBtn = document.getElementById('checkReadinessBtn');
        this.primaryAnimation = null;
        this.isAnimationPlaying = false;
        this.gestureHintTimer = null;
        this.isInARMode = false;
        this.animationStartedByUser = false;

        this.init();
      }
      
      init() {
        console.log('üéØ Initializing Mural AR Experience...');
        this.setupEventListeners();
        this.isAnimationPlaying = false;
      }

      setupEventListeners() {
        // Main model viewer events
        this.mv.addEventListener('load', () => {
          console.log('‚úÖ Model load event fired');
          this.hideLoader();
          this.prepareMuralAnimation();
          this.showGestureHint();
          this.playMuralAnimation({ force: true });
          this.logModelInfo();
        });

        // Add multiple loading completion checks
        this.mv.addEventListener('model-load', () => {
          console.log('‚úÖ Model-load event fired');
          this.onModelFullyLoaded();
        });

        this.mv.addEventListener('camera-change', () => {
          console.log('‚úÖ Camera-change event fired - model likely ready');
          this.onModelFullyLoaded();
        });
        
        this.mv.addEventListener('error', (e) => {
          console.error('‚ùå Model error:', e);
          console.error('‚ùå Error details:', e.detail);
          
          // Try fallback to non-Draco model
          if (this.mv.src.includes('pipeline')) {
            console.log('üîÑ Trying fallback to non-Draco model...');
            this.mv.src = '/assets/models/LCSE-AR-Back-Wall-Clean-Parented-no-draco.glb';
            document.getElementById('loadingText').textContent = 'Trying alternative model...';
          } else {
            document.getElementById('loadingText').textContent = 'Error loading model';
          }
        });

        // Add progress monitoring
        this.mv.addEventListener('progress', (e) => {
          const progress = e.detail.totalProgress;
          console.log(`üì• Loading progress: ${Math.round(progress * 100)}%`);
          if (progress < 1) {
            document.getElementById('loadingText').textContent = `Loading 3D models... ${Math.round(progress * 100)}%`;
          } else {
            // Progress complete, start readiness checks
            console.log('üì• Loading progress complete, checking model readiness...');
            setTimeout(() => this.checkModelReadiness(), 500);
          }
        });

        // Add periodic readiness checks
        this.startReadinessChecks();
        
        this.mv.addEventListener('play', () => {
          this.isAnimationPlaying = true;
        });

        this.mv.addEventListener('pause', () => {
          this.isAnimationPlaying = false;
        });
        
        // AR mode events
        this.mv.addEventListener('before-enter-ar', () => {
          this.isInARMode = true;
          this.animationStartedByUser = false;
          // Don't auto-play in AR mode on iOS - show control instead
          this.showAnimationControl();
        });

        this.mv.addEventListener('ar-status', (e) => {
          if (e.detail.status === 'session-started') {
            console.log('üöÄ AR session started');
            this.onARStart();
          } else if (e.detail.status === 'session-ended') {
            this.isInARMode = false;
            this.hideAnimationControl();
          }
        });
        
        this.mv.addEventListener('animation-finished', () => this.onAnimationFinished());

        // Animation control button
        this.playAnimationBtn.addEventListener('click', () => {
          this.startAnimationWithUserInteraction();
        });

        // Debug control buttons
        this.forceLoadBtn.addEventListener('click', () => {
          console.log('üîÑ Force loading model...');
          this.onModelFullyLoaded();
        });

        this.checkReadinessBtn.addEventListener('click', () => {
          this.checkModelReadiness();
        });

        // Show debug controls in development
        if (window.location.hostname === 'localhost' || window.location.hostname.includes('vercel')) {
          this.debugControls.style.display = 'block';
        }
      }
      
      hideLoader() {
        setTimeout(() => {
          this.loader.style.display = 'none';
        }, 1000);
      }

      prepareMuralAnimation() {
        const animations = this.mv.availableAnimations || [];
        if (!animations.length) {
          console.warn('‚ö†Ô∏è No animations detected on primary model');
          this.primaryAnimation = null;
          return;
        }

        this.primaryAnimation = animations[0];
        this.startPrimaryAnimation({ resetTime: true, force: true });
      }

      playMuralAnimation({ force = false, resetTime = false } = {}) {
        if (!this.primaryAnimation) {
          return;
        }

        if (this.isAnimationPlaying && !force) {
          return;
        }

        this.startPrimaryAnimation({ resetTime, force });
      }

      startPrimaryAnimation({ resetTime = false, force = false } = {}) {
        if (!this.primaryAnimation) {
          console.warn('‚ö†Ô∏è No primary animation available');
          return;
        }

        try {
          // Ensure model is fully loaded before setting animation
          if (!this.mv.model) {
            console.warn('‚ö†Ô∏è Model not fully loaded, waiting...');
            setTimeout(() => this.startPrimaryAnimation({ resetTime, force }), 500);
            return;
          }

          // Set animation properties
          this.mv.setAttribute('animation-name', this.primaryAnimation);
          this.mv.setAttribute('animation-loop', '');
          this.mv.setAttribute('autoplay', '');
          
          // Safely set animation name
          if (this.mv.animationName !== undefined) {
            this.mv.animationName = this.primaryAnimation;
          }

          if (resetTime) {
            this.mv.currentTime = 0;
          }

          // Add timeout to prevent hanging
          const animationTimeout = setTimeout(() => {
            if (this.isAnimationPlaying) {
              console.warn('‚ö†Ô∏è Animation may be frozen - attempting recovery');
              this.recoverFromFreeze();
            }
          }, 5000); // 5 second timeout

          const markAnimationStarted = () => {
            console.log('‚úÖ Animation started successfully');
            this.isAnimationPlaying = true;
            clearTimeout(animationTimeout);
            this.monitorPerformance();
          };

          const handleAnimationError = (error) => {
            console.error('‚ùå Unable to play mural animation:', error);
            this.isAnimationPlaying = false;
            clearTimeout(animationTimeout);

            // On iOS, try alternative approach
            if (this.isIOS()) {
              console.log('üîÑ Trying alternative animation start for iOS...');
              setTimeout(() => {
                try {
                  const retry = this.mv.play({ animationName: this.primaryAnimation });
                  if (retry && typeof retry.then === 'function') {
                    retry.then(markAnimationStarted).catch(e => {
                      console.error('‚ùå Alternative animation start also failed:', e);
                    });
                  } else {
                    markAnimationStarted();
                  }
                } catch (e) {
                  console.error('‚ùå Alternative animation start also failed:', e);
                }
              }, 100);
            }
          };

          // For iOS, we need to ensure the animation starts properly
          const playResult = this.mv.play({ animationName: this.primaryAnimation });

          if (playResult && typeof playResult.then === 'function') {
            playResult.then(markAnimationStarted).catch(handleAnimationError);
          } else {
            // Older Safari builds return void instead of a promise
            markAnimationStarted();
          }
        } catch (error) {
          console.error('‚ùå Error setting up animation:', error);
          this.isAnimationPlaying = false;
        }
      }

      showGestureHint() {
        if (!this.gestureHint) return;
        clearTimeout(this.gestureHintTimer);
        this.gestureHint.classList.add('visible');
        this.gestureHintTimer = setTimeout(() => {
          this.gestureHint.classList.remove('visible');
        }, 6000);
      }

      onARStart() {
        this.showGestureHint();
        // Only auto-play if not on iOS or if user has already interacted
        if (!this.isIOS() || this.animationStartedByUser) {
          this.playMuralAnimation({ force: true, resetTime: true });
        }
      }

      isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }

      showAnimationControl() {
        if (this.animationControl && this.isIOS()) {
          this.animationControl.style.display = 'block';
          // Auto-hide after 10 seconds if not clicked
          setTimeout(() => {
            if (!this.animationStartedByUser) {
              this.animationControl.style.display = 'none';
            }
          }, 10000);
        }
      }

      hideAnimationControl() {
        if (this.animationControl) {
          this.animationControl.style.display = 'none';
        }
      }

      startAnimationWithUserInteraction() {
        this.animationStartedByUser = true;
        this.hideAnimationControl();
        this.playMuralAnimation({ force: true, resetTime: true });
        console.log('üé¨ Animation started by user interaction');
      }

      onModelFullyLoaded() {
        console.log('üéØ Model fully loaded - attempting animation setup');
        
        // Wait a bit for everything to settle
        setTimeout(() => {
          this.prepareMuralAnimation();
          this.playMuralAnimation({ force: true });
          console.log('‚úÖ Animation setup completed after full load');
        }, 1000);
      }

      // Comprehensive loading detection
      checkModelReadiness() {
        const checks = {
          hasModel: !!this.mv.model,
          hasAnimations: !!(this.mv.availableAnimations && this.mv.availableAnimations.length > 0),
          isLoaded: this.mv.loaded,
          hasScene: !!(this.mv.model && this.mv.model.scene),
          progressComplete: this.mv.loadingProgress === 1.0
        };
        
        console.log('üîç Model readiness checks:', checks);
        
        const allReady = Object.values(checks).every(check => check === true);
        
        if (allReady) {
          console.log('‚úÖ All readiness checks passed - model is fully ready');
          this.onModelFullyLoaded();
          return true;
        }
        
        return false;
      }

      startReadinessChecks() {
        // Check every 2 seconds if model is ready
        const checkInterval = setInterval(() => {
          if (this.checkModelReadiness()) {
            clearInterval(checkInterval);
            console.log('‚úÖ Readiness checks stopped - model is ready');
          }
        }, 2000);

        // Stop checking after 30 seconds
        setTimeout(() => {
          clearInterval(checkInterval);
          console.log('‚è∞ Readiness checks timeout - proceeding anyway');
          this.onModelFullyLoaded();
        }, 30000);
      }

      logModelInfo() {
        try {
          const animations = this.mv.availableAnimations || [];
          console.log('üìä Model Information:');
          console.log('- Available animations:', animations.length);
          console.log('- Animations:', animations);
          
          // Get actual model size from the loaded model
          const modelSize = this.getModelSize();
          console.log(`- Model size: ~${modelSize}MB (pipeline optimized)`);
          console.log('- Device:', navigator.userAgent);
          console.log('- Memory:', navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'Unknown');
          
          // Check for performance issues
          if (this.isIOS()) {
            if (modelSize < 10) {
              console.log('‚úÖ iOS detected - model optimized for mobile performance');
              console.log('üí° Model size reduced significantly for better mobile experience');
            } else {
              console.log('‚ö†Ô∏è iOS detected - model may still cause performance issues');
              console.log('üí° Consider further optimization for mobile devices');
            }
          }
        } catch (error) {
          console.error('Error logging model info:', error);
        }
      }

      getModelSize() {
        try {
          // Try to get the actual file size from the model viewer
          const model = this.mv.model;
          if (model && model.userData && model.userData.fileSize) {
            return Math.round(model.userData.fileSize / (1024 * 1024));
          }
          
          // Fallback: estimate based on current model
          const currentSrc = this.mv.src;
          if (currentSrc.includes('pipeline')) return '7.7';
          if (currentSrc.includes('conservative')) return '3.5';
          if (currentSrc.includes('optimized')) return '1.6';
          return '20';
        } catch (error) {
          console.warn('Could not determine model size:', error);
          return 'Unknown';
        }
      }

      monitorPerformance() {
        // Monitor frame rate and performance
        let frameCount = 0;
        let lastTime = performance.now();
        
        const checkPerformance = () => {
          frameCount++;
          const currentTime = performance.now();
          
          if (currentTime - lastTime >= 1000) {
            const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
            console.log(`üìà Performance: ${fps} FPS`);
            
            if (fps < 30) {
              console.warn('‚ö†Ô∏è Low FPS detected - model may be too complex for device');
            }
            
            frameCount = 0;
            lastTime = currentTime;
          }
          
          if (this.isAnimationPlaying) {
            requestAnimationFrame(checkPerformance);
          }
        };
        
        requestAnimationFrame(checkPerformance);
      }

      recoverFromFreeze() {
        console.log('üîÑ Attempting to recover from animation freeze...');
        try {
          // Stop current animation
          this.mv.pause();
          this.isAnimationPlaying = false;
          
          // Reset model viewer
          this.mv.currentTime = 0;
          
          // Try to restart after a brief delay
          setTimeout(() => {
            console.log('üîÑ Restarting animation after recovery...');
            this.playMuralAnimation({ force: true, resetTime: true });
          }, 1000);
          
        } catch (error) {
          console.error('‚ùå Recovery failed:', error);
        }
      }
    }
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.muralAR = new MuralARExperience();
      console.log('üéØ Mural AR Experience initialized');
    });
  </script>
</body>
</html>
